import React, { useState, useEffect, useCallback, useRef, useMemo } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faPhone, faPhoneSlash, faEye } from "@fortawesome/free-solid-svg-icons";
import Vapi from "@vapi-ai/web";
import vivaService from "../services/vivaService";
import VivaEvaluate from './VivaEvaluate';

// Initialize Vapi with public key
const vapi = new Vapi(import.meta.env.VITE_VAPI_PUBLIC_KEY);

const VapiStudentAssistant = ({ viva, studentId, onComplete }) => {
  const [isActive, setIsActive] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [isListening, setIsListening] = useState(false);
  const [error, setError] = useState(null);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [responses, setResponses] = useState([]);
  const [feedback, setFeedback] = useState(null);
  const [assistantScore, setAssistantScore] = useState(0);
  const [messages, setMessages] = useState([]);
  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false);
  const [callStarted, setCallStarted] = useState(false);
  const [hasConcluded, setHasConcluded] = useState(false);
  const [expectedQuestion, setExpectedQuestion] = useState(null);
  const messagesEndRef = useRef(null);
  const [updatedAnswers, setUpdatedAnswers] = useState([]);
  const [totalMarks, setTotalMarks] = useState(0);
  const [maxTotalMarks, setMaxTotalMarks] = useState(0);

  // Video URLs for assistant states
  const videoUrls = {
    idle: "/videos/robot-start.mp4",
    listening: "/videos/robot-listening.mp4",
    speaking: "/videos/robot-speaking.mp4",
    thinking: "/videos/robot-listening.mp4",
    loading: "/videos/robot-start.mp4",
  };

  // Determine current video state
  const currentVideoState = useMemo(() => {
    if (isConnecting) return "loading";
    if (isSpeaking) return "speaking";
    if (isListening || isWaitingForResponse) return "listening";
    if (hasConcluded && !callStarted) return "idle";
    return "idle";
  }, [isConnecting, isSpeaking, isListening, isWaitingForResponse, hasConcluded, callStarted]);

  // Memoize questions to avoid repeated logging
  const questions = useMemo(() => {
    const extractedQuestions = viva?.questions?.map((q) => q.question) || [];
    console.log("Viva Schema:", viva);
    console.log("Extracted Questions:", extractedQuestions);
    return extractedQuestions;
  }, [viva]);

  // Scroll to bottom of messages
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const sendQuestion = useCallback(
    (index) => {
      console.log(`sendQuestion called with index: ${index}, questions length: ${questions.length}`);
      
      if (hasConcluded) {
        console.log("Viva has already concluded, stopping further questions.");
        return;
      }

      let messageContent;
      if (index < questions.length) {
        messageContent = questions[index];
        setExpectedQuestion(messageContent);
        setCurrentQuestionIndex(index);
        setIsWaitingForResponse(true);
      } else {
        messageContent = "The viva has concluded. Thank you for participating!";
        setHasConcluded(true);
        setIsWaitingForResponse(false);
      }

      vapi.send({
        type: "add-message",
        message: { role: "assistant", content: messageContent },
      });

      setMessages((prev) => [
        ...prev,
        { role: "assistant", content: messageContent, timestamp: new Date() },
      ]);
    },
    [questions, hasConcluded]
  );

  const handleCallStart = useCallback(() => {
    console.log("Call started");
    setIsActive(true);
    setIsConnecting(false);
    setError(null);
    setCallStarted(true);
    setMessages([]);
    setResponses([]);
    setFeedback(null);
    setAssistantScore(0);
    setCurrentQuestionIndex(0);
    setIsWaitingForResponse(false);
    setHasConcluded(false);
    setExpectedQuestion(null);
    setIsListening(false);

    const introMessage = "Hello, I am your viva assistant. I'm here to conduct your viva examination. Let's dive in and have a great session!";
    
    vapi.send({
      type: "add-message",
      message: { role: "assistant", content: introMessage },
    });
    
    setMessages([
      { role: "assistant", content: introMessage, timestamp: new Date() },
    ]);

    setTimeout(() => {
      sendQuestion(0);
    }, 2000);
  }, [sendQuestion]);

  
// Update the handleCallEnd function
const handleCallEnd = useCallback(async () => {
  console.log("Call ended");
  setIsActive(false);
  setIsConnecting(false);
  setIsSpeaking(false);
  setIsListening(false);
  setCallStarted(false);
  setIsWaitingForResponse(false);

  try {
    // Get the transcript from messages
    const transcript = messages
      .map(m => `${m.role}: ${m.content}`)
      .join('\n');
     console.log("Transcript:", transcript);
    // Create evaluations array from responses
    const evaluations = await Promise.all(
      responses.map(async (response, index) => {
        const question = questions[index];
        const prompt = `
          Evaluate this viva answer:
          Question: ${question}
          Response: ${response}
          Provide feedback and score (0-${viva.difficulty === 'easy' ? 3 : viva.difficulty === 'medium' ? 5 : 7})
          Return as JSON: {"marks": number, "feedback": "string"}
        `;

        try {
          const response = await fetch(`${import.meta.env.VITE_BACKEND_URL}/api/viva/evaluate`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ prompt })
          });

          const result = await response.json();
          return {
            question,
            response,
            marks: result.marks,
            feedback: result.feedback
          };
        } catch (error) {
          console.error("Evaluation error:", error);
          return {
            question,
            response,
            marks: 0,
            feedback: "Evaluation failed"
          };
        }
      })
    );

    // Calculate scores
    const maxMarksPerQuestion = 
      viva.difficulty === "easy" ? 3 : 
      viva.difficulty === "medium" ? 5 : 7;
    
    const totalObtainedMarks = evaluations.reduce((sum, evaal) => sum + evaal.marks, 100);
    const maxPossibleMarks = questions.length * maxMarksPerQuestion;
    const percentageScore = Math.round((totalObtainedMarks / maxPossibleMarks) * 100);

    // Generate overall feedback
    const feedbackPrompt = `
      Based on this viva transcript and evaluations:
      Transcript: ${transcript}
      Evaluations: ${JSON.stringify(evaluations)}
      Generate comprehensive feedback including:
      - Overall performance assessment
      - Strengths
      - Areas for improvement
      - Final score: ${percentageScore}%
    `;

    const feedbackResponse = await fetch(`${import.meta.env.VITE_BACKEND_URL}/api/viva/feedback`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ prompt: feedbackPrompt })
    });

    const feedbackResult = await feedbackResponse.json();

    // Save results
    setTotalMarks(totalObtainedMarks);
    setMaxTotalMarks(maxPossibleMarks);
    setAssistantScore(percentageScore);
    setFeedback(feedbackResult.feedback);

    // Submit to backend
    await vivaService.submitViva(viva._id, evaluations);

    // Call completion handler
    if (onComplete) {
      onComplete({
        answers: evaluations,
        totalMarks: totalObtainedMarks,
        maxMarks: maxPossibleMarks,
        feedback: feedbackResult.feedback
      });
    }

  } catch (err) {
    console.error("Error in handleCallEnd:", err);
    setError("Failed to complete viva evaluation. Please try again.");
  }
}, [responses, questions, viva, onComplete, messages]);
// ...existing code...

  const handleViewFeedback = useCallback(() => {
    const redirectParams = new URLSearchParams();
    redirectParams.append("score", encodeURIComponent(assistantScore));
    redirectParams.append("feedback", encodeURIComponent(feedback));
    window.location.href = `/viva-feedback?${redirectParams.toString()}`;
  }, [assistantScore, feedback]);

  const handleSpeechStart = useCallback(() => {
    setIsSpeaking(true);
    setIsListening(false);
  }, []);

  const handleSpeechEnd = useCallback(() => {
    setIsSpeaking(false);
    if (isWaitingForResponse) {
      setIsListening(true);
    }
  }, [isWaitingForResponse]);

  const handleError = useCallback((error) => {
    console.error("Vapi error:", error);
    setError(error.message || "Failed to connect to the assistant.");
    setIsActive(false);
    setIsConnecting(false);
    setIsSpeaking(false);
    setIsListening(false);
    setCallStarted(false);
    setIsWaitingForResponse(false);
    setHasConcluded(false);
    setMessages((prev) => [
      ...prev,
      { role: "system", content: "Connection error. Please try again.", timestamp: new Date() },
    ]);
  }, []);

  const handleMessage = useCallback(
    (message) => {
      if (hasConcluded) {
        console.log("Viva has concluded, ignoring message:", message);
        return;
      }

      if (message.role === "assistant" && message.content) {
        const expectedMessages = [
          expectedQuestion,
          "Take your time and answer confidently!",
          "The viva has concluded. Thank you for participating!",
          "The call is now ending.",
          "Hello, I am your viva assistant. I'm here to conduct your viva examination. Let's dive in and have a great session!",
        ].filter(Boolean);

        const isFeedbackMessage = message.content.toLowerCase().includes("feedback");
        const isExpected = expectedMessages.some((exp) => message.content === exp) || isFeedbackMessage;

        if (!isExpected) {
          console.log("Unexpected assistant message, stopping assistant");
          vapi.stop();
          return;
        }

        setMessages((prev) => [
          ...prev,
          { role: "assistant", content: message.content, timestamp: new Date() },
        ]);
      } else if (message.role === "user" || (message.type === "transcript" && message.transcript)) {
        const transcriptContent = message.transcript || message.content;
        
        if (transcriptContent) {
          setMessages((prev) => [
            ...prev,
            { role: "user", content: transcriptContent, timestamp: new Date() },
          ]);

          if (isWaitingForResponse) {
            setResponses((prev) => [...prev, transcriptContent]);
            setIsWaitingForResponse(false);
            setTimeout(() => {
              sendQuestion(currentQuestionIndex + 1);
            }, 2000);
          }
        }
      }
    },
    [currentQuestionIndex, isWaitingForResponse, sendQuestion, hasConcluded, expectedQuestion]
  );

  const endViva = useCallback(() => {
    if (callStarted) {
      vapi.stop();
      setIsActive(false);
      setIsConnecting(false);
      setIsSpeaking(false);
      setIsListening(false);
      setIsWaitingForResponse(false);
      setCallStarted(false);
      setHasConcluded(true);
      if (!messages.some((m) => m.content.includes("The viva has concluded"))) {
        sendQuestion(questions.length);
      }
      setTimeout(() => handleCallEnd(), 4000);
    }
  }, [callStarted, handleCallEnd, sendQuestion, questions.length, messages]);

  const startViva = useCallback(async () => {
    try {
      setIsConnecting(true);
      setCallStarted(true);

      const vapiConfig = {
        transcriber: {
          provider: "deepgram",
          model: "nova-2",
          language: "en-US",
        },
        model: {
          provider: "openai",
          model: "gpt-3.5-turbo",
          temperature: 0.7,
          messages: [
            {
              role: "system",
              content: `You are a viva teacher conducting a viva examination for student ID ${studentId} on the topic "${viva.topic}". 
              The viva consists of ${viva.numberOfQuestions} questions with a ${viva.difficulty} difficulty level. 
              Follow these steps in a professional yet encouraging tone:
              make sure you should only ask ${viva.numberOfQuestions} questions and not more than that.
              1. Start with: "Hello, I am your viva assistant. I'm here to conduct your viva examination. Let's dive in and have a great session!"
              2. Ask the questions regarding the topic.
              3. After each question, say: "Take your time and answer confidently!"
              4. Wait for the student's response before proceeding.
              5. After the last question, announce: "The viva has concluded. Thank you for participating!"
              6. End with: "The viva is now ending."`,
            },
          ],
        },
        voice: {
          provider: "playht",
          voiceId: "jennifer",
        },
      };

      // Set up event listeners
      vapi.on("speech-start", handleSpeechStart);
      vapi.on("speech-end", handleSpeechEnd);
      vapi.on("call-start", handleCallStart);
      vapi.on("call-end", handleCallEnd);
      vapi.on("error", handleError);
      vapi.on("message", handleMessage);

      await vapi.start(vapiConfig);
    } catch (err) {
      console.error("startViva error:", err);
      handleError(err);
    }
  }, [
    studentId,
    viva,
    handleSpeechStart,
    handleSpeechEnd,
    handleCallStart,
    handleCallEnd,
    handleError,
    handleMessage,
  ]);

  useEffect(() => {
    const handleBeforeUnload = (e) => {
      if (callStarted) {
        e.preventDefault();
        e.returnValue = "Are you sure you want to leave? Your viva progress will be lost.";
      }
    };
    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => window.removeEventListener("beforeunload", handleBeforeUnload);
  }, [callStarted]);

  useEffect(() => {
    return () => {
      if (callStarted) {
        vapi.stop();
      }
    };
  }, [callStarted]);

  if (error) {
    return (
      <div className="text-center text-red-500 font-semibold">
        {error}
        <button
          onClick={() => window.location.reload()}
          className="mt-4 px-6 py-3 bg-teal-500 text-white rounded-lg font-semibold hover:bg-teal-600 transition-colors duration-300"
        >
          Retry
        </button>
      </div>
    );
  }

  // Replace the existing feedback condition with this enhanced version
if (feedback && !callStarted) {
  return (
    <div className="flex flex-col items-center justify-center min-h-[50vh] bg-gray-100 rounded-lg p-6">
      <video
        src={videoUrls.idle}
        autoPlay
        loop
        muted
        className="w-48 h-48 mb-4 rounded-full shadow-lg"
      />
      <div className="text-center">
        <h2 className="text-2xl font-bold text-gray-800 mb-2">
          Viva Completed
        </h2>
        <div className="feedback-section">
          <h3 className="feedback-title">Your Performance</h3>
          <div className="feedback-content">
            <p className="mb-2">
              Score: <span className="feedback-score">{assistantScore}%</span>
            </p>
            <p className="mb-2">
              Marks: {totalMarks}/{maxTotalMarks}
            </p>
          </div>
        </div>
        <button
          onClick={handleViewFeedback}
          className="px-6 py-3 bg-teal-500 text-white rounded-lg font-semibold hover:bg-teal-600 transition-colors duration-300 shadow-md flex items-center mx-auto mt-4"
        >
          <FontAwesomeIcon icon={faEye} className="mr-2" />
          View Detailed Feedback
        </button>
      </div>
    </div>
  );
}

  return (
    <div className="flex flex-col items-center justify-center min-h-[50vh] bg-gray-100 rounded-lg p-6">
      <div className="relative">
        <video
          src={videoUrls[currentVideoState]}
          autoPlay
          loop
          muted
          className="w-48 h-48 rounded-full shadow-lg"
        />
        {isActive && (
          <div className="absolute top-0 right-0 w-4 h-4 bg-red-500 rounded-full shadow-md animate-pulse" />
        )}
      </div>

      <div className="mt-4 w-full text-center">
        {messages.length > 0 && (
          <p className="text-gray-800 text-lg font-semibold">
            {messages[messages.length - 1].content}
          </p>
        )}
      </div>

      <div className="mt-4 w-full text-center">
        {isConnecting && (
          <p className="text-gray-500 text-lg font-semibold">
            Connecting to the assistant...
          </p>
        )}
        {isActive && isSpeaking && (
          <p className="text-teal-500 text-lg font-semibold">
            Assistant is speaking...
          </p>
        )}
        {isActive && isListening && (
          <p className="text-blue-500 text-lg font-semibold">
            Listening to your response...
          </p>
        )}
      </div>

      <div className="mt-6 flex space-x-4">
        {!callStarted ? (
          <button
            onClick={startViva}
            className="px-6 py-3 bg-teal-500 text-white rounded-lg font-semibold hover:bg-teal-600 transition-colors duration-300 shadow-md flex items-center"
          >
            <FontAwesomeIcon icon={faPhone} className="mr-2" />
            Start Viva
          </button>
        ) : (
          <button
            onClick={endViva}
            className="px-6 py-3 bg-red-500 text-white rounded-lg font-semibold hover:bg-red-600 transition-colors duration-300 shadow-md flex items-center"
          >
            <FontAwesomeIcon icon={faPhoneSlash} className="mr-2" />
            End Viva
          </button>
        )}
      </div>
      <div ref={messagesEndRef} />
    </div>
  );
};

export default VapiStudentAssistant;

// Add these styles in the existing return statement before the closing div
const feedbackStyles = `
  .feedback-section {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 20px;
    margin-top: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .feedback-title {
    color: #3dffa2;
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 12px;
  }

  .feedback-content {
    color: #ffffff;
    font-size: 1rem;
    line-height: 1.6;
  }

  .feedback-score {
    display: inline-block;
    background: #3dffa2;
    color: #1a1a1a;
    padding: 4px 12px;
    border-radius: 999px;
    font-weight: 600;
    margin-top: 12px;
  }
`;